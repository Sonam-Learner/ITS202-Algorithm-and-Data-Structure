\documentclass[11pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usetheme{Copenhagen}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{outlines}
\setbeamertemplate{caption}[numbered]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}


% Code
\usepackage{courier} %% Sets font for listing as Courier.
\usepackage{listings, xcolor}
\lstset{
	tabsize = 4, %% set tab space width
	showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
	numbers = left, %% display line numbers on the left
	commentstyle = \color{red}, %% set comment color
	keywordstyle = \color{blue}, %% set keyword color
	stringstyle = \color{red}, %% set string color
	rulecolor = \color{black}, %% set frame color to avoid being affected by text color
	basicstyle = \small \ttfamily , %% set listing font and size
	breaklines = true, %% enable line breaking
	numberstyle = \tiny,
}


\begin{document}
	\author{Sonam Wangmo}
	\title{Key Indexed Counting}
	%\subtitle{}
	%\logo{}
	\institute{Gyalpozhing College of Information Technology}
	\subject{ITS202: Algorithms and Data Structure}
	%\date{}
	\setbeamercovered{transparent}
	%\setbeamertemplate{navigation symbols}{}
	\begin{frame}[plain]
		\maketitle
	\end{frame}
	
	\begin{frame}
		\frametitle{Key Indexed Counting}
			\begin{itemize}
			\item 	A simple method for sorting that is effective whenever the keys are small integers.\\
		
			\item There are mainly four steps in processing key-indexed counting sort.
			\begin{enumerate}
				\item Compute frequency counts.
				\item Transform counts to indices.
				\item Distribute the data.
				\item Copy back.
				\end{enumerate}		 
		\end{itemize}	
	\end{frame}

\begin{frame}
	\frametitle{Example: Inputs are given below}
		% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[htbp]
  \centering
  \caption{array a[]}
    \begin{tabular}{lr}
    Anderson & 2 \\
    Brown & 3 \\
    Davis & 3 \\
    Garcia & 4 \\
    Harris & 1 \\
    Jackson & 3 \\
    Johnson & 4 \\
    Jones & 3 \\
    Martin & 1 \\
    Martinez & 2 \\
    Miller & 2 \\
    Moore & 1 \\
    Robinson & 2 \\
    Smith & 4 \\
    Taylor & 3 \\
    \end{tabular}%
  \label{}%
\end{table}%

\end{frame}

\begin{frame}[fragile]
	\frametitle{1. Compute frequency counts}
	The first step is to count the frequency of occurrence of each key value, using an int array count[]. For each item, we use the key to access an entry in count[] and increment that entry.  If the key value is r, we increment count[r+1].\\
	
	\begin{lstlisting}[language=Java]
		
		for (i = 0; i < N; i++)
		count[a[i].key() + 1]++;
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{2.Transform counts to indices }
	Next,we use count[] to compute, for each key value, the starting index positions in the sorted order of items with that key.\\
		\begin{lstlisting}[language=Java]
		
		for (int r = 0; r < R; r++)
		count[r+1] += count[r];
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{3. Distribute the data }
	With the count[] array transformed into an index table, we accomplish the actual sort by moving the items to an auxiliary array aux[]. \\
	\begin{lstlisting}[language=Java]
		
		for (int i = 0; i < N; i++)
		aux[count[a[i].key()]++] = a[i]
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{4. Copy back }
	Since we accomplished the sort by moving the items to an auxiliary array, the last step is to copy the sorted result back to the original array. \\
	\begin{lstlisting}[language=Java]
		for (int i = 0; i < N; i++)
		a[i] = aux[i]
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key-indexed counting (a[].key is an int in [0, R). }
	\begin{lstlisting}[language=Java]
		int N = a.length;
		String[] aux = new String[N];
		int[] count = new int[R+1];
		// Compute frequency counts.
		for (int i = 0; i < N; i++)
		count[a[i].key() + 1]++;
		// Transform counts to indices.
		for (int r = 0; r < R; r++)
		count[r+1] += count[r];
		// Distribute the records.
		for (int i = 0; i < N; i++)
		aux[count[a[i].key()]++] = a[i];
		// Copy back.
		for (int i = 0; i < N; i++)
		a[i] = aux[i];
		
	\end{lstlisting}
\end{frame}

\begin{frame}
	Q. Do key indexing counting sort for the given array. 
	\begin{figure}
		\centering
		\includegraphics[width=0.4\linewidth]{"Screenshot 2020-10-14 at 10.10.56 AM"}
		\caption{a[i]}
		\label{fig:screenshot-2020-10-14-at-10}
	\end{figure}
	
\end{frame}

\begin{frame}[fragile]
	\frametitle{Running Time of Key Indexed Counting }
	\begin{itemize}
		\item key-indexed counting does no compares (it accesses data only through key()). When R is within a constant factor of N, we have a linear-time sort.
		\item O(N+ R)
		R can be characters of alphabets, Hence we ignore R.
		\item O(N)
	\end{itemize}
\end{frame}

\end{document}